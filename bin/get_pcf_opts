#!/usr/bin/perl
#
#  Script to extract the parameters used in the input files for a PCF.  
#  Mainly used to check consistency.
#  Output parameters in a CSV file format.
#
#  Should be run in the GPSUSER directory.  
#
#  Input is the name of the PCF file
#

use strict;
use Getopt::Std;
use LINZ::BERN::PcfFile;

my $syntax=<<EOD;
get_pcf_opts:  Script to extract the options used in a PCF file into a CSV file.

Syntax: get_pcf_opts [-a] pcf_name [csv_file_name]

The script must be run in the GPSUSER directory.

If the -a option is selected then only the active options are output.  Those are
the options for which active conditions apply, and which are in panels listed as
active.

The default csv file name is the PCF name with .csv appended.

EOD

my %opts;
getopts('a',\%opts);
my $activeonly=$opts{a};

scalar(@ARGV)>=1 || die $syntax;
my $pcf=$ARGV[0];
my $csvf=$ARGV[1] || $pcf.'.csv';

$pcf .= '.PCF' if $pcf !~ /\.PCF$/i;
$pcf = "PCF/$pcf";

-d 'PCF' || die "PCF directory not found, are you in a GPSUSER directory?\n";
-d 'SCRIPT' || die "SCRIPT directory not found, are you in a GPSUSER directory?\n";
-d 'OPT' || die "OPT directory not found, are you in a GPSUSER directory?\n";

$ENV{U}='.';
my $pcff=LINZ::BERN::PcfFile->open($pcf);

# Process the PCF file to find the list of scripts and options it uses...

my $files={$pcf=>1};

my $scripts=[];
foreach my $pid ($pcff->pids())
{
    foreach my $pgm (@{$pid->{programs}})
    {
        push(@$scripts,{script=>$pid->{script},opt=>$pid->{optdir},program=>$pgm});
    }
}

my @params=();
my %pans=();

foreach my $script (@$scripts)
{
    my $opt=$script->{opt};
    my $pgm=$script->{program};
    my $script=$script->{script};
    my $panfile="OPT/$opt/$pgm.INP";
    next if $pans{$panfile};
    $pans{$panfile}=1;

    my $inpf;
    if( ! open($inpf,"<$panfile") )
    {
        print "Cannot open $panfile\n";
        next;
    }
    my $line='';
    my @fparams=();
    my %fdescr=();
    my %prmval=();
    my %panprm=();
    while(1) 
    {
        $line = <$inpf> if ! $line;
        last if ! $line;
        my $l=$line;
        $line='';

        if( $l =~ /^\#+\s+BEGIN_PANEL\s+([^\#]*)\#+\s*$/ )
        {
            my $pcond=$1 || '1';
            while( $l = <$inpf> )
            {
                last if $l =~ /^\#+\s+END_PANEL\s+\#*$/;
                next if $l !~ /\#\s+(\w[\w\s]*)$/;
                my $params=$1;
                foreach my $prm (split(' ',$params))
                {
                    $panprm{$prm}=[] if ! exists $panprm{$prm};
                    push(@{$panprm{$prm}},$pcond);
                }
            }
            next;
        }
        next if $l =~ /^\s*(\#|\!|$)/;
        next if $l =~ /^\s*DESCR_/;
        if($l =~ /^\s*MSG_(\w+)\s+1\s+(\S.*?)\s*$/)
        {
            my $param=$1;
            my $descr=$2;
            $descr =~ s/\"//g;
            $fdescr{$param}=$descr;
            next;
        };
        if($l =~ /^\s*ENVIRONMENT\s+(\d+)\s*$/)
        {
            my $nenv=$1;
            while($nenv--)
            {
                my $nextline=<$inpf>;
            }
            next;
        }
        next if $l !~ /^\s*(\w+)\s+(\d+)(?:\s+\"([^\"]*)\")?\s*$/;
        my ($param,$count,$value)=($1,$2,$3);
        if( $count > 1 )
        {
            $value=[];
            while($count--)
            {
                $l = <$inpf>;
                push(@$value,$1) if $l =~ /^\s*\"([^\"]*)\"\s*$/;
            }
            $value=join("\n",@$value);
        }
        $value =~ s/\"/\"\"/g;
        my $cond='1';
        while( $line = <$inpf> )
        {
            if( $line =~ /^\s+\#\#/ )
            {
                if( $line =~ /\sactiveif\s+\=\s+([^\;]*)/)
                {
                    $cond=$1;
                    $cond=~ s/\s*$//;
                }
                next;
            }
            last if $line !~ /^\s+\#\s+(.*?)\s$/;
            $value=$1;
            $line='';
            last;
        }
        push(@fparams,{param=>$param,cond=>$cond,value=>$value});
        $prmval{$param}=$value;
    }
    foreach my $fp (@fparams)
    {
        my $param=$fp->{param};
        my $active=0;
        if( exists $panprm{$param} )
        {
            foreach my $cond (@{$panprm{$param}})
            {
                $active=evalcond($cond,\%prmval);
                last if $active;
            }
        }
        $active = evalcond($fp->{cond},\%prmval) if $active;
        $active = 0 if ! $active;
        next if $activeonly && ! $active;
        push(@params,sprintf("%s,%s,%s,%s,\"%s\",\"%s\"\n",
                $opt,$pgm,$param,
                $active,
                $fp->{value},
                $fdescr{$param}));
    }
}

open(my $csv,">$csvf") || die "Cannot create $csvf\n";
print $csv "OPT,PGM,PARAM,ACTIVE,VALUE,DESCRIPTION\n",@params;
close($csv);
print "$pcf options written to $csvf\n";

sub evalcond
{
    my ($cond,$prmval)=@_;
    $cond =~ s/\s*$//;
    $cond =~ s/^\s*//;
    return 1 if $cond eq '1';
    return 1 if $cond eq 'NO_CONDITION';
    return 0 if $cond eq '';
    my $status=0;
    my @checks=split(' ',$cond);
    unshift(@checks,'OR');
    while( scalar(@checks) >= 4 )
    {
        my ($op,$var,$cmp,$val) = splice(@checks,0,4);
        $op = uc($op);

        if( $op eq 'AND' )
        {
            return $status if ! $status;
        }
        elsif( $op eq 'OR' )
        {
            return $status if $status;
        }
        else
        {
            print "Unknown logical op $op ($cond)\n";
        }

        $var=$prmval->{$var};
        $val='' if $val eq '_';

        if( $cmp eq '=' || $cmp eq '==')
        {
            $status = 1 if $var eq $val;
        }
        elsif( $cmp eq '/' || $cmp eq '/=')
        {
            $status = 1 if $var ne $val;
        }
        elsif( $cmp eq '>' )
        {
            $status = 1 if $var > $val;
        }
        elsif( $cmp eq '<' )
        {
            $status = 1 if $var < $val;
        }
        else
        {
            print "Unknown comparison $cmp ($cond)\n";
        }
    }
    return $status;
}
